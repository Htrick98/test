1
00:00:00,000 --> 00:00:03,402
[MUSIC PLAYING]

2
00:00:03,402 --> 00:00:08,750


3
00:00:08,750 --> 00:00:10,730
MATT SULLIVAN: Good
morning, and welcome

4
00:00:10,730 --> 00:00:13,790
to the build reactive
apps with Flutter session.

5
00:00:13,790 --> 00:00:15,255
My name is Matt Sullivan.

6
00:00:15,255 --> 00:00:16,880
FILIP HRACEK: And my
name Filip Hracek,

7
00:00:16,880 --> 00:00:20,970
and we're both developer
advocates on the Flutter team.

8
00:00:20,970 --> 00:00:24,000
مات سوليفان : لذلك دعونا نبدأ بالنظر في كيفية إنشاء

9
00:00:24,000 --> 00:00:26,060
تطبيقات تفاعلية على Flutter.

10
00:00:26,060 --> 00:00:29,504
فلاتر يتيح لك بناء تطبيقات جميلة.

11
00:00:29,504 --> 00:00:30,920
يمنحك القدرة على إنشاء

12
00:00:30,920 --> 00:00:34,430
واجهات مستخدم معقدة ومخصصة ومتطورة

13
00:00:34,430 --> 00:00:36,530
بعض الأمثلة هنا فقط لتظهر لك

14
00:00:36,530 --> 00:00:39,470
مجموعة وأنواع التطبيقات المختلفة

15
00:00:39,470 --> 00:00:42,920
التي يمكنك إنشاؤها باستخدام فلاتر.

16
00:00:42,920 --> 00:00:47,230
At the heart of Flutter's UI
is a powerful, reactive model.

17
00:00:47,230 --> 00:00:49,730
I'm going to give you the 30
second summary of how it works,

18
00:00:49,730 --> 00:00:51,960
and then we're going to
deep dive into things.

19
00:00:51,960 --> 00:00:55,820
أولاً ، في فلاتر ، جميع مكونات واجهة المستخدم عبارة عن  ويدجت.

20
00:00:55,820 --> 00:00:59,000
كما ترون هنا ، لدينا عنصر واجهة مستخدم وهو زر.

21
00:00:59,000 --> 00:01:02,960
ثانياً ، تأخذ هذه الـ widgets وتقوم بتكوينها معًا

22
00:01:02,960 --> 00:01:04,724
لإنشاء واجهات مستخدم معقدة.

23
00:01:04,724 --> 00:01:06,140
لذلك ، سوف نشير مرارًا وتكرارًا

24
00:01:06,140 --> 00:01:08,750
 إلى ما نسميه شجرة القطعة ،

25
00:01:08,750 --> 00:01:10,790
وهذا هو بالضبط كيف نبنيها معًا.

26
00:01:10,790 --> 00:01:13,070
ثالثًا ، والأهم من ذلك ، أن فلاتر

27
00:01:13,070 --> 00:01:16,490
يدير العلاقة بين الحالة وواجهة المستخدم ،

28
00:01:16,490 --> 00:01:18,320
ولا يعيد إنشاء هذه التطبيقات المصغّرة إلا عندما

29
00:01:18,320 --> 00:01:20,690
تتغير حالتها ،

30
00:01:20,690 --> 00:01:22,350
ويريحك من الاضطرار للقيام بهذه المهمة.

31
00:01:22,350 --> 00:01:25,910
لذلك ، على سبيل المثال ، هنا ، عندما نستدعي setState () في أداة الترحيب ،

32
00:01:25,910 --> 00:01:29,980
ستعيد رسم نفسها تلقائيًا.

33
00:01:29,980 --> 00:01:33,190
وهذا أمر عظيم ورائع، لكن بناء التطبيقات المعقدة

34
00:01:33,190 --> 00:01:34,390
ليس بالأمر السهل.

35
00:01:34,390 --> 00:01:36,970
تحتوي التطبيقات عادة على الآلاف من مكونات واجهة المستخدم ،

36
00:01:36,970 --> 00:01:39,580
ولكن الأهم من ذلك ، أنها معقدة للغاية ،

37
00:01:39,580 --> 00:01:41,710
وحالة معقدة

38
00:01:41,710 --> 00:01:44,350
يحتمل أن تتفاعل مع مكونات واجهة المستخدم هذه بشكل غير متزامن

39
00:01:44,350 --> 00:01:48,190
في أوقات مختلفة في تطبيقك.

40
00:01:48,190 --> 00:01:51,350
والخبر السار هو أن فلاتر يوفر لك

41
00:01:51,350 --> 00:01:55,580
جميع الأدوات اللازمة ، ليس فقط لبناء واجهة مستخدم ،

42
00:01:55,580 --> 00:01:59,240
ولكن أيضًا للتعامل مع تدفق البيانات المعقدة والحالة

43
00:01:59,240 --> 00:02:01,970
في تطبيقك الذي يتناسب بشكل رائع

44
00:02:01,970 --> 00:02:05,390
مع نموذج فلاتر التفاعلي لبناء واجهات المستخدم.

45
00:02:05,390 --> 00:02:07,850
Now, Flutter's UI
patterns are well-known

46
00:02:07,850 --> 00:02:10,550
and well-documented-- you can
check them out on flutter.io--

47
00:02:10,550 --> 00:02:13,490
but Flutter's reactive
strategies for handling state

48
00:02:13,490 --> 00:02:14,900
are not so well-known.

49
00:02:14,900 --> 00:02:19,160
So we're going to focus
the talk on how to do that.

50
00:02:19,160 --> 00:02:21,099
We're going to take
you on a journey.

51
00:02:21,099 --> 00:02:23,515
Firstly, we're going to look
at the foundations of Flutter

52
00:02:23,515 --> 00:02:27,410
and state to show you the
basis of how things work.

53
00:02:27,410 --> 00:02:28,910
What we're going
to do then is we're

54
00:02:28,910 --> 00:02:31,820
going to explore how
state and the widget tree

55
00:02:31,820 --> 00:02:33,530
can be married together.

56
00:02:33,530 --> 00:02:35,450
And thirdly, we're
going to look at how

57
00:02:35,450 --> 00:02:38,810
you can use Flutter
streams to elegantly manage

58
00:02:38,810 --> 00:02:40,672
state in your app.

59
00:02:40,672 --> 00:02:43,130
Now, at each of these, we're
going to do some live coding--

60
00:02:43,130 --> 00:02:45,200
and clearly, nothing
is not going to run.

61
00:02:45,200 --> 00:02:47,420
But we're going to
do some live coding,

62
00:02:47,420 --> 00:02:50,600
and these examples will
be relatively simple.

63
00:02:50,600 --> 00:02:52,610
But we want you to
keep in mind how

64
00:02:52,610 --> 00:02:56,210
these can be scaled out to more
complex state, and larger apps.

65
00:02:56,210 --> 00:02:58,700
And importantly, the
examples you'll see here

66
00:02:58,700 --> 00:03:01,190
have been derived from
production apps built

67
00:03:01,190 --> 00:03:05,880
with Flutter, both by
Google and by other parties.

68
00:03:05,880 --> 00:03:11,037
So let's dive in and look at
managing state in the simplest

69
00:03:11,037 --> 00:03:13,370
app we can think of, which
is the incrementor app, which

70
00:03:13,370 --> 00:03:17,460
is what you get out of the box
when you do Flutter create.

71
00:03:17,460 --> 00:03:20,090
Flutter's reactive model
is straightforward for UI

72
00:03:20,090 --> 00:03:22,190
and state, but it's
a little different

73
00:03:22,190 --> 00:03:25,340
to how things are handled
with Android and iOS.

74
00:03:25,340 --> 00:03:28,700
So we're going to dive in
by looking at this app,

75
00:03:28,700 --> 00:03:32,450
and we're going to look at a
common pitfall that typically

76
00:03:32,450 --> 00:03:34,340
catches people out
when they initially

77
00:03:34,340 --> 00:03:37,490
start thinking about
reactive systems in general.

78
00:03:37,490 --> 00:03:38,490
Filip.

79
00:03:38,490 --> 00:03:39,490
FILIP HRACEK: All right.

80
00:03:39,490 --> 00:03:41,830
So this is a very
exciting moment for me,

81
00:03:41,830 --> 00:03:44,545
because I'm going to
break an app on stage

82
00:03:44,545 --> 00:03:47,570
at IO, which, if
you think about it,

83
00:03:47,570 --> 00:03:49,630
that's exactly the opposite
of what you normally

84
00:03:49,630 --> 00:03:51,060
want to do on stage.

85
00:03:51,060 --> 00:03:53,890
Well, this is in the name
of learning and science,

86
00:03:53,890 --> 00:03:56,830
so it's OK.

87
00:03:56,830 --> 00:03:59,410
So if you're not
familiar with this app,

88
00:03:59,410 --> 00:04:02,080
this app is very exciting.

89
00:04:02,080 --> 00:04:07,420
It shows you a number, and it
lets you increment that number.

90
00:04:07,420 --> 00:04:12,970
The important parts are there
is the counter variable,

91
00:04:12,970 --> 00:04:17,430
there's the build method
that creates the UI.

92
00:04:17,430 --> 00:04:21,519
Here is the widget which
actually shows that number--

93
00:04:21,519 --> 00:04:23,090
number four, right now.

94
00:04:23,090 --> 00:04:24,920
And here's the
floating action button,

95
00:04:24,920 --> 00:04:27,490
which is this guy
over here, which

96
00:04:27,490 --> 00:04:30,380
lets you change that variable.

97
00:04:30,380 --> 00:04:33,760
Now, imagine that this
was a much bigger app,

98
00:04:33,760 --> 00:04:38,170
and we wanted to put a
little more structure to it.

99
00:04:38,170 --> 00:04:41,530
We would do that,
often, by extracting

100
00:04:41,530 --> 00:04:45,640
parts of the build method
into its own widget.

101
00:04:45,640 --> 00:04:48,610
So I'm going to do just that.

102
00:04:48,610 --> 00:04:55,840
I'm going to take this out,
create a new widget called

103
00:04:55,840 --> 00:05:03,340
incrementor, and I'm just going
to paste the code over here.

104
00:05:03,340 --> 00:05:04,540
We're not done.

105
00:05:04,540 --> 00:05:08,300
As you can see, there's red
squiggly lines over there,

106
00:05:08,300 --> 00:05:10,220
which means we have a problem.

107
00:05:10,220 --> 00:05:13,060
And the problem is that
we cannot actually access

108
00:05:13,060 --> 00:05:17,260
the counter variable from here,
because we're in this class,

109
00:05:17,260 --> 00:05:21,700
while the counter
variable is in this class.

110
00:05:21,700 --> 00:05:25,130
There are many ways
to solve this problem,

111
00:05:25,130 --> 00:05:27,730
but I have something
very special in mind.

112
00:05:27,730 --> 00:05:34,300
I'm just going to make the
viable global, because I can.

113
00:05:34,300 --> 00:05:36,050
MATT SULLIVAN: So there
you have it folks.

114
00:05:36,050 --> 00:05:39,470
To handle state in Flutter,
you make everything global,

115
00:05:39,470 --> 00:05:40,460
and your app is good.

116
00:05:40,460 --> 00:05:41,480
Yeah-- is that what
we're telling people?

117
00:05:41,480 --> 00:05:41,985
[CHUCKLES]

118
00:05:41,985 --> 00:05:42,986
FILIP HRACEK: No.

119
00:05:42,986 --> 00:05:46,700
Actually, we're trying
to make the point here--

120
00:05:46,700 --> 00:05:49,670
we're trying to break
this app, so please don't

121
00:05:49,670 --> 00:05:51,910
make your variables global.

122
00:05:51,910 --> 00:05:58,890
And we're going to fix this in
two minutes, so stay with us.

123
00:05:58,890 --> 00:06:03,170
We fixed the squiggly lines, so
let's see if this app actually

124
00:06:03,170 --> 00:06:04,730
works, now.

125
00:06:04,730 --> 00:06:05,720
It doesn't.

126
00:06:05,720 --> 00:06:08,900
Now, why is that?

127
00:06:08,900 --> 00:06:14,720
We can add a thing here to see
if the counter variable has

128
00:06:14,720 --> 00:06:16,430
actually changed.

129
00:06:16,430 --> 00:06:19,430
And we see that it
has-- it is now at 12.

130
00:06:19,430 --> 00:06:22,370
But the user doesn't see it.

131
00:06:22,370 --> 00:06:23,700
Why is that?

132
00:06:23,700 --> 00:06:27,560
Well, the reason is that we're
calling setState() in the wrong

133
00:06:27,560 --> 00:06:28,430
widget.

134
00:06:28,430 --> 00:06:33,050
We're breaking the contract
of set state, which

135
00:06:33,050 --> 00:06:35,840
is that you call set state
when you are changing

136
00:06:35,840 --> 00:06:37,550
the state of the widget.

137
00:06:37,550 --> 00:06:40,640
We're not changing the state
of the floating action button

138
00:06:40,640 --> 00:06:45,260
here, we're changing the
state of the widget above it.

139
00:06:45,260 --> 00:06:48,280
And that way, Flutter
doesn't know--

140
00:06:48,280 --> 00:06:50,900
Flutter tries to rebuild
that floating action button,

141
00:06:50,900 --> 00:06:54,170
but that doesn't do anything
with our text over here.

142
00:06:54,170 --> 00:06:55,540
So I'm going to fix it now.

143
00:06:55,540 --> 00:06:58,135


144
00:06:58,135 --> 00:06:59,510
MATT SULLIVAN:
What we need to do

145
00:06:59,510 --> 00:07:02,150
is we need to move set state
into the appropriate widget

146
00:07:02,150 --> 00:07:04,999
where we want to show the
change, or the mutation,

147
00:07:04,999 --> 00:07:05,540
of the state.

148
00:07:05,540 --> 00:07:11,600
So Filip is going to move it
back into the home page widget.

149
00:07:11,600 --> 00:07:14,270
And thankfully, we no longer
have any more global state.

150
00:07:14,270 --> 00:07:16,179
Wonderful.

151
00:07:16,179 --> 00:07:17,720
What we're going to
do then is-- what

152
00:07:17,720 --> 00:07:19,520
we need to do is we need
to be able to pass down

153
00:07:19,520 --> 00:07:22,250
a reference to that function so
it can be called by its child

154
00:07:22,250 --> 00:07:23,120
widget.

155
00:07:23,120 --> 00:07:25,730
So we're basically going to
update the incrementor widget,

156
00:07:25,730 --> 00:07:28,940
we're going to pass
through the function

157
00:07:28,940 --> 00:07:30,165
through the constructor.

158
00:07:30,165 --> 00:07:31,790
And then, what this
is basically giving

159
00:07:31,790 --> 00:07:33,800
is the classic callback
method of being

160
00:07:33,800 --> 00:07:37,310
able to call the function
in the parent widget.

161
00:07:37,310 --> 00:07:40,296
And that should
probably just work.

162
00:07:40,296 --> 00:07:41,420
FILIP HRACEK: And it works.

163
00:07:41,420 --> 00:07:43,100
Awesome.

164
00:07:43,100 --> 00:07:43,600
All right.

165
00:07:43,600 --> 00:07:44,730
Back to slides, please.

166
00:07:44,730 --> 00:07:47,870


167
00:07:47,870 --> 00:07:51,560
So that was great, and it
was pretty easy to fix.

168
00:07:51,560 --> 00:07:53,320
But you can imagine
that if you have

169
00:07:53,320 --> 00:07:57,550
a much larger app with
a lot more widgets,

170
00:07:57,550 --> 00:07:59,060
this could be a problem.

171
00:07:59,060 --> 00:08:03,010
Let's imagine that you
need state over here,

172
00:08:03,010 --> 00:08:06,580
and you have state
somewhere over here.

173
00:08:06,580 --> 00:08:10,720
And now, what you need to do
is, if you follow that pattern

174
00:08:10,720 --> 00:08:13,960
that I just showed you, you
need to pass down the state

175
00:08:13,960 --> 00:08:15,460
down the widget tree.

176
00:08:15,460 --> 00:08:19,300
And that means that all the
widgets that are in that path

177
00:08:19,300 --> 00:08:21,820
need to know about the state,
even though they don't really

178
00:08:21,820 --> 00:08:23,190
care.

179
00:08:23,190 --> 00:08:27,800
And that breaks reuse, it
breaks separation of concerns,

180
00:08:27,800 --> 00:08:30,160
and it also, potentially,
makes the app

181
00:08:30,160 --> 00:08:33,710
rebuild a much larger
portion of the state--

182
00:08:33,710 --> 00:08:35,799
of the UI than you would want.

183
00:08:35,799 --> 00:08:39,919
You only want the leaf
nodes to be rebuilt.

184
00:08:39,919 --> 00:08:45,880
So I've hopefully highlighted
two problems here, or two

185
00:08:45,880 --> 00:08:47,050
challenges.

186
00:08:47,050 --> 00:08:51,250
First, how do I access state
that doesn't necessarily

187
00:08:51,250 --> 00:08:55,150
live in the widget where
I need it, and second,

188
00:08:55,150 --> 00:08:59,260
how do I notify other widgets
that they should rebuild?

189
00:08:59,260 --> 00:09:02,350


190
00:09:02,350 --> 00:09:06,430
Again, I'm going to
score this pattern

191
00:09:06,430 --> 00:09:10,420
that I just showed you with
thumbs down on both accounts,

192
00:09:10,420 --> 00:09:14,710
because while it is easy in
a simple app, in a big app,

193
00:09:14,710 --> 00:09:17,390
it gets more complicated.

194
00:09:17,390 --> 00:09:21,670
And I think we have
a better option here.

195
00:09:21,670 --> 00:09:25,829
MATT SULLIVAN: So let's look
at how we can handle state,

196
00:09:25,829 --> 00:09:28,120
and the concept of passing
state up and down the widget

197
00:09:28,120 --> 00:09:31,420
tree without having to expose
it to all the widgets in between

198
00:09:31,420 --> 00:09:33,730
that don't need to use it.

199
00:09:33,730 --> 00:09:37,270
Flutter has, out
of the box, what

200
00:09:37,270 --> 00:09:39,010
is called an InheritedWidget.

201
00:09:39,010 --> 00:09:43,640
And what an inherited widget
does is it holds state,

202
00:09:43,640 --> 00:09:47,690
and it allows you to propagate
that state efficiently

203
00:09:47,690 --> 00:09:51,380
down the widget tree, and
it will rebuild that widget

204
00:09:51,380 --> 00:09:56,610
tree when that state is
mutated, or that state changes.

205
00:09:56,610 --> 00:09:58,985
So that sounds promising--
that might help us solve this.

206
00:09:58,985 --> 00:10:00,318
What is this going to look like?

207
00:10:00,318 --> 00:10:02,240
Well, basically you have
an InheritedWidget--

208
00:10:02,240 --> 00:10:03,115
we've put it in here.

209
00:10:03,115 --> 00:10:05,720
And as opposed to having to
pass down references to it,

210
00:10:05,720 --> 00:10:08,360
we can use the
build context in any

211
00:10:08,360 --> 00:10:11,930
of the build methods to get an
access to the instance of that

212
00:10:11,930 --> 00:10:16,710
state and use it directly
within our widgets themselves.

213
00:10:16,710 --> 00:10:19,100
So what does that
look like in code?

214
00:10:19,100 --> 00:10:23,210
Here, I have my really cleverly
named MyInheritedWidget,

215
00:10:23,210 --> 00:10:25,790
which extends InheritedWidget,
and in here, you

216
00:10:25,790 --> 00:10:28,430
can see that I have
placed some state.

217
00:10:28,430 --> 00:10:29,330
Perfect.

218
00:10:29,330 --> 00:10:30,590
How do I access that?

219
00:10:30,590 --> 00:10:33,290
Well, I can access
it by, firstly,

220
00:10:33,290 --> 00:10:38,510
placing my InheritedWidget into
my tree, giving it some state,

221
00:10:38,510 --> 00:10:42,150
and then building the
widget tree beneath it.

222
00:10:42,150 --> 00:10:43,970
And then, after
that, I can access it

223
00:10:43,970 --> 00:10:46,220
by simply using
the build context

224
00:10:46,220 --> 00:10:48,290
to get a reference
to that widget,

225
00:10:48,290 --> 00:10:49,790
and then I can access the state.

226
00:10:49,790 --> 00:10:51,830
So that sounds promising.

227
00:10:51,830 --> 00:10:55,460
Well, sure-- now I can access
state anywhere in the tree,

228
00:10:55,460 --> 00:10:57,860
and keep the rest
of my code dry.

229
00:10:57,860 --> 00:10:59,720
My tree, at a
coarse grain level,

230
00:10:59,720 --> 00:11:02,340
does rebuild my state
changes, so that's OK.

231
00:11:02,340 --> 00:11:05,300
But, as you noticed,
my state was final.

232
00:11:05,300 --> 00:11:08,390
That's not very
helpful if you actually

233
00:11:08,390 --> 00:11:09,800
want to mutate your state.

234
00:11:09,800 --> 00:11:14,087
Now, it's not hard to layer in
mutation with InheritedWidget--

235
00:11:14,087 --> 00:11:15,170
it's a bit of boilerplate.

236
00:11:15,170 --> 00:11:16,711
What we're going to
do is we're going

237
00:11:16,711 --> 00:11:18,980
to look at a library
called ScopedModel.

238
00:11:18,980 --> 00:11:21,020
And ScopedModel is
an external package.

239
00:11:21,020 --> 00:11:23,180
It's built on top
of InheritedWidget,

240
00:11:23,180 --> 00:11:25,850
and importantly, it
gives us the access,

241
00:11:25,850 --> 00:11:27,680
it gives us a more
fine-grained way

242
00:11:27,680 --> 00:11:30,770
of rebuilding parts of
our tree, and it allows

243
00:11:30,770 --> 00:11:33,750
us to mutate state, as well.

244
00:11:33,750 --> 00:11:36,200
So looking at code
real quick, ScopedModel

245
00:11:36,200 --> 00:11:38,420
equates to my InheritedWidget.

246
00:11:38,420 --> 00:11:41,060
And we have what's called
a descendent, which

247
00:11:41,060 --> 00:11:43,820
gives us access to the state.

248
00:11:43,820 --> 00:11:45,470
I'm showing all this
stuff on slides--

249
00:11:45,470 --> 00:11:49,440
I want to show it in real
code to show you it working.

250
00:11:49,440 --> 00:11:52,100
But I don't want to show it
to you in the incrementor app

251
00:11:52,100 --> 00:11:53,780
because that's pretty simple.

252
00:11:53,780 --> 00:11:57,110
So Filip and I knocked up
a shopping cart example.

253
00:11:57,110 --> 00:12:00,050
And what that has is it
has three areas where

254
00:12:00,050 --> 00:12:01,950
you need to handle your state.

255
00:12:01,950 --> 00:12:04,310
We've got a cart page which
shows the list of items,

256
00:12:04,310 --> 00:12:06,590
we have a cart button which
shows the number of items

257
00:12:06,590 --> 00:12:09,140
in the cart, and we
have a grid of products,

258
00:12:09,140 --> 00:12:12,350
where each product is tappable,
and should add something

259
00:12:12,350 --> 00:12:13,970
to the cart.

260
00:12:13,970 --> 00:12:27,330
So let's jump over to my
laptop, and take a look at this.

261
00:12:27,330 --> 00:12:30,600
Here, we have the app,
which is already running.

262
00:12:30,600 --> 00:12:32,350
You can see I have
a grid of products.

263
00:12:32,350 --> 00:12:34,349
And at the moment, it's
just showing a snack bar

264
00:12:34,349 --> 00:12:35,280
at the bottom.

265
00:12:35,280 --> 00:12:39,060
We have my cart button, which
is hard-coded to show zero,

266
00:12:39,060 --> 00:12:41,739
and we have a cart page, which
currently is showing empty.

267
00:12:41,739 --> 00:12:43,780
There is no state anywhere
in here at the moment.

268
00:12:43,780 --> 00:12:45,180
These are all
stateless widgets--

269
00:12:45,180 --> 00:12:47,520
this does nothing
except look pretty--

270
00:12:47,520 --> 00:12:49,310
if you consider
this to be pretty.

271
00:12:49,310 --> 00:12:52,850
We're not designers,
but there you go.

272
00:12:52,850 --> 00:12:53,770
What do we need to do?

273
00:12:53,770 --> 00:12:57,070
First, we need to
define our model.

274
00:12:57,070 --> 00:12:59,310
So I have created cart model.

275
00:12:59,310 --> 00:13:00,870
It extends model,
and what it does

276
00:13:00,870 --> 00:13:04,440
is it simply has a cart object
which is holding our state.

277
00:13:04,440 --> 00:13:07,060
We have three different ways
of interacting with this.

278
00:13:07,060 --> 00:13:09,870
We've got a getter to pull
down the list of cart items,

279
00:13:09,870 --> 00:13:12,557
we have item count
which gives us

280
00:13:12,557 --> 00:13:13,890
the number of items in the cart.

281
00:13:13,890 --> 00:13:17,560
And, strangely enough, we have
an add method, or function,

282
00:13:17,560 --> 00:13:19,860
which allows us to place
a product in the cart.

283
00:13:19,860 --> 00:13:23,340
Now, notice here, when I
mutate or change my state,

284
00:13:23,340 --> 00:13:25,680
I'm explicitly calling
notify listeners.

285
00:13:25,680 --> 00:13:27,900
And the way ScopedModel
works is that whenever

286
00:13:27,900 --> 00:13:32,070
you have a descendent widget,
they are observing your state--

287
00:13:32,070 --> 00:13:33,990
they are listening for changes.

288
00:13:33,990 --> 00:13:37,200
And, when our state changes, we
simply call notify listeners,

289
00:13:37,200 --> 00:13:39,090
and all of those
descendent widgets

290
00:13:39,090 --> 00:13:43,410
will be notified that state has
changed, and they will rebuild.

291
00:13:43,410 --> 00:13:45,630
So the whole tree is
not being rebuilt,

292
00:13:45,630 --> 00:13:47,910
only those widgets that
are listening to it,

293
00:13:47,910 --> 00:13:50,700
and the things below them
will be rebuilt. Perfect.

294
00:13:50,700 --> 00:13:53,070
So let's see how I
can use that model

295
00:13:53,070 --> 00:13:56,034
to inject some state to my app.

296
00:13:56,034 --> 00:13:57,450
What I'm going to
do is I'm simply

297
00:13:57,450 --> 00:14:00,330
going to place my state at
the topmost level of my app

298
00:14:00,330 --> 00:14:01,300
for ease to begin with.

299
00:14:01,300 --> 00:14:03,090
What I'm going to
do is I am going

300
00:14:03,090 --> 00:14:05,820
to wrap this in a
new widget, and it

301
00:14:05,820 --> 00:14:08,410
is going to be a ScopedModel.

302
00:14:08,410 --> 00:14:09,930
And, as we can see
here, ScopedModel

303
00:14:09,930 --> 00:14:12,240
takes a model and a child.

304
00:14:12,240 --> 00:14:16,350
So we can keep the subtree as a
child, and I can place a model.

305
00:14:16,350 --> 00:14:19,410
And I'm going to create a
new instance of cart model.

306
00:14:19,410 --> 00:14:22,160


307
00:14:22,160 --> 00:14:24,960
So now I have state existing
at the top of my tree.

308
00:14:24,960 --> 00:14:25,460
Great.

309
00:14:25,460 --> 00:14:27,800
I need to access that
state, so how do I do it?

310
00:14:27,800 --> 00:14:29,732
Let's go down and take
a look at our button.

311
00:14:29,732 --> 00:14:31,940
And here's our button, and
you can see at the moment,

312
00:14:31,940 --> 00:14:33,984
it's hard-coded to show zero.

313
00:14:33,984 --> 00:14:35,900
So what I'm going to do
is I'm going to follow

314
00:14:35,900 --> 00:14:36,983
the same type of pattern--

315
00:14:36,983 --> 00:14:38,690
I'm going to wrap
this in a new widget.

316
00:14:38,690 --> 00:14:43,850
And, this time, I'm going
to use a descendant widget.

317
00:14:43,850 --> 00:14:47,660
I'm going to type it so it knows
what type of model to look for.

318
00:14:47,660 --> 00:14:49,190
And this doesn't
take a child, it

319
00:14:49,190 --> 00:14:52,520
takes a builder, which will
provide me with the model.

320
00:14:52,520 --> 00:14:54,800
So I'm going to change
my child to builder--

321
00:14:54,800 --> 00:14:57,480
and this is a function.

322
00:14:57,480 --> 00:15:05,580
I need the build context because
that's how InheritedWidget

323
00:15:05,580 --> 00:15:06,810
gets a reference to it.

324
00:15:06,810 --> 00:15:09,060
We have an optional child
widget I'm not going to use,

325
00:15:09,060 --> 00:15:10,735
and we're going to have a model.

326
00:15:10,735 --> 00:15:11,610
So what can I do now?

327
00:15:11,610 --> 00:15:16,590
I should be able to simply
do model dot item count.

328
00:15:16,590 --> 00:15:17,090
Perfect.

329
00:15:17,090 --> 00:15:19,131
We got to do one more
thing to get this to work--

330
00:15:19,131 --> 00:15:20,730
we've got to add some products.

331
00:15:20,730 --> 00:15:22,360
I'm going to do
this super quick.

332
00:15:22,360 --> 00:15:25,920
Here, we have our grid, here,
we have our individual products.

333
00:15:25,920 --> 00:15:28,080
And, again, I'm going to
follow the same pattern--

334
00:15:28,080 --> 00:15:33,020
I'm going to wrap this
in a descendant widget.

335
00:15:33,020 --> 00:15:34,360
I'm going to type it--

336
00:15:34,360 --> 00:15:36,040
and I'm going to
do that properly.

337
00:15:36,040 --> 00:15:39,380
And then, again, I'm going
to change this to a builder,

338
00:15:39,380 --> 00:15:47,310
make this a function, take
my context and my model.

339
00:15:47,310 --> 00:15:49,350
And so, now, what
we can do in here

340
00:15:49,350 --> 00:15:51,570
is-- we've got all
of this snack bar

341
00:15:51,570 --> 00:15:53,140
code, which I can get rid of.

342
00:15:53,140 --> 00:15:55,950
And I should be able
to do model dot add--

343
00:15:55,950 --> 00:15:59,670
and we have a product.

344
00:15:59,670 --> 00:16:04,100


345
00:16:04,100 --> 00:16:05,290
This is all hot reloaded--

346
00:16:05,290 --> 00:16:06,415
I've placed state in there.

347
00:16:06,415 --> 00:16:08,690
I don't have to restart
my app, fingers crossed.

348
00:16:08,690 --> 00:16:12,170
And we'll see if this works.

349
00:16:12,170 --> 00:16:12,720
There we go.

350
00:16:12,720 --> 00:16:14,780
So we've gone from
stateless to stateful.

351
00:16:14,780 --> 00:16:17,060
I haven't changed the
structure of my app.

352
00:16:17,060 --> 00:16:19,820
All I've done is I've layered
in a few extra widgets.

353
00:16:19,820 --> 00:16:22,340
And with the way that
this app is built,

354
00:16:22,340 --> 00:16:23,960
this has worked really nicely.

355
00:16:23,960 --> 00:16:26,870
FILIP HRACEK: This is
nice Matt, but didn't you

356
00:16:26,870 --> 00:16:29,750
say that whenever you
call notify listeners,

357
00:16:29,750 --> 00:16:33,990
you will rebuild the things
below the descendants?

358
00:16:33,990 --> 00:16:37,060
Which means that we are
now rebuilding the product

359
00:16:37,060 --> 00:16:39,107
squares every time you click.

360
00:16:39,107 --> 00:16:40,940
MATT SULLIVAN: So, as
we pointed out before,

361
00:16:40,940 --> 00:16:42,860
notify listeners notifies
all the descendants.

362
00:16:42,860 --> 00:16:45,530
So we're rebuilding this
button, but we're also

363
00:16:45,530 --> 00:16:48,310
rebuilding all of these
products, which is bad.

364
00:16:48,310 --> 00:16:49,970
So why don't we fix
that real quick.

365
00:16:49,970 --> 00:16:54,050
Because ScopedModel descendant
has a rebuild unchanged flag--

366
00:16:54,050 --> 00:16:57,710
and I can set that to false.

367
00:16:57,710 --> 00:16:59,660
And so you shouldn't
see any difference here.

368
00:16:59,660 --> 00:17:04,900
What's happening now
is these products

369
00:17:04,900 --> 00:17:07,280
squares are not being rebuilt.

370
00:17:07,280 --> 00:17:10,910
I already implemented a
descendant for the cart page,

371
00:17:10,910 --> 00:17:13,920
because you don't need to see
me type this a third time,

372
00:17:13,920 --> 00:17:16,819
but it's exactly the
same model there.

373
00:17:16,819 --> 00:17:19,650
So let's jump back
to the slides.

374
00:17:19,650 --> 00:17:20,150
Thank you.

375
00:17:20,150 --> 00:17:23,280


376
00:17:23,280 --> 00:17:24,329
So what does that get us?

377
00:17:24,329 --> 00:17:27,569
Accessing state-- we can access
state arbitrarily down the tree

378
00:17:27,569 --> 00:17:31,590
without having to mess with
our intermediate widgets.

379
00:17:31,590 --> 00:17:33,660
We have a reasonably
elegant means

380
00:17:33,660 --> 00:17:36,240
of notifying our widgets now
by our descendants observing

381
00:17:36,240 --> 00:17:39,630
for state change,
and then rebuilding

382
00:17:39,630 --> 00:17:41,029
when that state changes.

383
00:17:41,029 --> 00:17:43,320
Now, minimal rebuild-- I'm
going to give a thumbs down,

384
00:17:43,320 --> 00:17:47,587
and that's because I had
to, a, be reminded by Filip,

385
00:17:47,587 --> 00:17:49,920
because I constantly forgot
every time we rehearsed this

386
00:17:49,920 --> 00:17:51,030
to do this--

387
00:17:51,030 --> 00:17:54,030
that we had to not
rebuild that part.

388
00:17:54,030 --> 00:17:56,610
There's a cognitive load at
that point for the developers.

389
00:17:56,610 --> 00:17:58,740
You need to work out
should this rebuild,

390
00:17:58,740 --> 00:18:01,170
shouldn't this rebuild,
what's going to happen?

391
00:18:01,170 --> 00:18:03,300
And, when you
evolve your app, you

392
00:18:03,300 --> 00:18:06,379
have this additional level of
needing to worry about this.

393
00:18:06,379 --> 00:18:07,920
So I don't think
this is great, and I

394
00:18:07,920 --> 00:18:09,480
think we probably
need to come up

395
00:18:09,480 --> 00:18:11,850
with a better solution to that.

396
00:18:11,850 --> 00:18:15,420
Funnily enough, we're now going
to look at Flutter support

397
00:18:15,420 --> 00:18:16,440
for streams.

398
00:18:16,440 --> 00:18:19,230
How streams can be built to fit
in with Flutter's UI reactive

399
00:18:19,230 --> 00:18:22,290
model, and how they can
solve this very problem.

400
00:18:22,290 --> 00:18:26,290


401
00:18:26,290 --> 00:18:27,310
FILIP HRACEK: Thank you.

402
00:18:27,310 --> 00:18:29,110
So let's talk about streams.

403
00:18:29,110 --> 00:18:32,920
If you are more familiar
with the term Observables,

404
00:18:32,920 --> 00:18:35,690
they are very closely related.

405
00:18:35,690 --> 00:18:38,140
And, for the
purposes of our talk,

406
00:18:38,140 --> 00:18:40,310
they are basically
interchangeable.

407
00:18:40,310 --> 00:18:43,300
So if you think about
application development,

408
00:18:43,300 --> 00:18:45,130
streams are everywhere.

409
00:18:45,130 --> 00:18:49,690
Every user input is a stream
of asynchronous events.

410
00:18:49,690 --> 00:18:52,840
Every interaction with
the underlying system

411
00:18:52,840 --> 00:18:55,870
is a stream of
asynchronous events.

412
00:18:55,870 --> 00:18:58,795
Every interaction-- obviously,
with the outside world through

413
00:18:58,795 --> 00:18:59,980
the network--

414
00:18:59,980 --> 00:19:02,170
is a stream of
asynchronous events.

415
00:19:02,170 --> 00:19:04,420
And crucially, if
you think about it,

416
00:19:04,420 --> 00:19:08,750
all your updates to the UI is a
stream of asynchronous events.

417
00:19:08,750 --> 00:19:12,130
So people who are
familiar with ReactiveX

418
00:19:12,130 --> 00:19:15,010
and reactive programming,
in general, probably

419
00:19:15,010 --> 00:19:16,510
know where I'm going with this.

420
00:19:16,510 --> 00:19:18,610
But suffice to
say, it makes sense

421
00:19:18,610 --> 00:19:21,370
to think about UI
programming as managing

422
00:19:21,370 --> 00:19:24,340
stream of asynchronous events.

423
00:19:24,340 --> 00:19:28,330
The good news is Dart has really
good support for streams--

424
00:19:28,330 --> 00:19:31,510
it has had that for a long time.

425
00:19:31,510 --> 00:19:35,050
Dart Streams have all the
usual bells and whistles

426
00:19:35,050 --> 00:19:40,420
that you would expect, like
stream transforming, mapping,

427
00:19:40,420 --> 00:19:42,440
folding, and so on.

428
00:19:42,440 --> 00:19:45,760
And Dart even has language
level support for streams,

429
00:19:45,760 --> 00:19:52,240
like asynchronous generators,
the yield keyword, or wait for.

430
00:19:52,240 --> 00:19:56,110
So we have this concept
of streams in Dart,

431
00:19:56,110 --> 00:20:00,070
and it is used throughout
the Dart ecosystem.

432
00:20:00,070 --> 00:20:05,110
And then we have this concept
of reactive extensions

433
00:20:05,110 --> 00:20:06,610
and reactive programming.

434
00:20:06,610 --> 00:20:08,500
On top of that,
there is a package

435
00:20:08,500 --> 00:20:13,990
called our rxdart, which builds
the reactive extensions on top

436
00:20:13,990 --> 00:20:19,390
of the inherent streams in Dart.

437
00:20:19,390 --> 00:20:21,880
So that's really great.

438
00:20:21,880 --> 00:20:24,880
How does that fit into Flutter?

439
00:20:24,880 --> 00:20:27,970
Well, Flutter has
this widget called

440
00:20:27,970 --> 00:20:32,110
StreamBuilder, which is exactly
what you would think it is.

441
00:20:32,110 --> 00:20:36,120
It is a widget that takes
a stream as an input,

442
00:20:36,120 --> 00:20:39,700
and a builder method that
will rebuild every time there

443
00:20:39,700 --> 00:20:42,990
is a new value in the stream.

444
00:20:42,990 --> 00:20:44,920
Any time you have
a stream, like when

445
00:20:44,920 --> 00:20:47,480
you're subscribing to
a FirebaseDatabase,

446
00:20:47,480 --> 00:20:51,500
you can just use StreamBuilder
to rebuild your UI.

447
00:20:51,500 --> 00:20:53,710
So that is already pretty cool.

448
00:20:53,710 --> 00:20:56,770
But wouldn't it be
even more awesome

449
00:20:56,770 --> 00:20:59,710
if we had some kind of
architectural pattern

450
00:20:59,710 --> 00:21:02,300
to build our apps?

451
00:21:02,300 --> 00:21:04,960
So imagine that
you have a big app,

452
00:21:04,960 --> 00:21:08,000
and it has some widgets
that take user input,

453
00:21:08,000 --> 00:21:11,650
so they have streams of
asynchronous events coming

454
00:21:11,650 --> 00:21:13,010
from the user.

455
00:21:13,010 --> 00:21:14,920
And then you have
other widgets that

456
00:21:14,920 --> 00:21:17,330
can be anywhere
else in the widget

457
00:21:17,330 --> 00:21:22,060
tree that try to update whenever
there is a state change.

458
00:21:22,060 --> 00:21:26,570
Now, you cannot just simply
link those two together--

459
00:21:26,570 --> 00:21:30,340
you need something in between,
and we'll call that business

460
00:21:30,340 --> 00:21:33,400
logic, for now.

461
00:21:33,400 --> 00:21:37,360
You need to stream the
events from the widgets that

462
00:21:37,360 --> 00:21:40,690
have buttons and inputs
to the business logic.

463
00:21:40,690 --> 00:21:44,650
Then, their magic happens,
and the business logic

464
00:21:44,650 --> 00:21:47,650
publishes streams
of data changes

465
00:21:47,650 --> 00:21:50,680
to widgets that are
interested in it.

466
00:21:50,680 --> 00:21:53,590
And this can then rebuild.

467
00:21:53,590 --> 00:21:56,860
Crucially, you're
publishing separate streams,

468
00:21:56,860 --> 00:22:00,130
so the other widget could be
interested in a completely

469
00:22:00,130 --> 00:22:02,920
different aspect of your
data, and it will just

470
00:22:02,920 --> 00:22:05,770
subscribe to that stream.

471
00:22:05,770 --> 00:22:08,530
It won't rebuild
any time there's

472
00:22:08,530 --> 00:22:10,580
any change to your model--

473
00:22:10,580 --> 00:22:12,250
it will only rebuild
when there is

474
00:22:12,250 --> 00:22:16,480
a change to that specific
aspect of the model.

475
00:22:16,480 --> 00:22:17,530
Let's have a closer look.

476
00:22:17,530 --> 00:22:20,380
We have streams as inputs,
and streams as outputs.

477
00:22:20,380 --> 00:22:22,810
How would that look in Dart?

478
00:22:22,810 --> 00:22:24,910
Well, we would
have an object that

479
00:22:24,910 --> 00:22:28,480
has Sinks of events as inputs.

480
00:22:28,480 --> 00:22:34,210
Sinks is the input of a
stream-- you put things into it,

481
00:22:34,210 --> 00:22:36,910
and then you can listen
to it on the other hand.

482
00:22:36,910 --> 00:22:40,720
And then there is a
stream of data as output.

483
00:22:40,720 --> 00:22:44,110
Pretty simple.

484
00:22:44,110 --> 00:22:47,560
Now, in our example
with a shopping app,

485
00:22:47,560 --> 00:22:51,710
the simplest possible
cart would be

486
00:22:51,710 --> 00:22:55,600
to have a single product called
addition, to which you would

487
00:22:55,600 --> 00:22:58,300
just shove your products into.

488
00:22:58,300 --> 00:23:00,890
And then it would have
a stream of integers,

489
00:23:00,890 --> 00:23:03,460
called itemCount, which
would update every time

490
00:23:03,460 --> 00:23:04,645
the item count changes.

491
00:23:04,645 --> 00:23:09,550


492
00:23:09,550 --> 00:23:11,950
Internally at Google, we
call these business logic

493
00:23:11,950 --> 00:23:17,170
components, so that
is bloc for short.

494
00:23:17,170 --> 00:23:18,500
Let's switch to the computer.

495
00:23:18,500 --> 00:23:22,420
And I'm going to
implement it real quick.

496
00:23:22,420 --> 00:23:24,880
So this would be my computer.

497
00:23:24,880 --> 00:23:27,390
Yes, I have the same app--

498
00:23:27,390 --> 00:23:31,180
it doesn't change-- it
doesn't currently work.

499
00:23:31,180 --> 00:23:35,980
And we'll need to
implement this pattern.

500
00:23:35,980 --> 00:23:38,140
So I already have
a cart provider

501
00:23:38,140 --> 00:23:43,270
that uses InheritedWidget
so that I can access cart--

502
00:23:43,270 --> 00:23:48,030
this object from
anywhere in my tree.

503
00:23:48,030 --> 00:23:51,640
And, as you can see, I'm
creating this object here,

504
00:23:51,640 --> 00:23:55,940
and then I'm accessing it in
different parts of my app.

505
00:23:55,940 --> 00:23:58,480
But I'm not doing
anything with it, yet.

506
00:23:58,480 --> 00:24:03,010
Also, if you look at the
object now, or the component,

507
00:24:03,010 --> 00:24:07,600
it is pretty empty-- it only
has the underlying model.

508
00:24:07,600 --> 00:24:11,530
So what I'm going to do is
I'm going to first implement

509
00:24:11,530 --> 00:24:14,170
the Sink of products--

510
00:24:14,170 --> 00:24:15,640
the streaming input.

511
00:24:15,640 --> 00:24:17,500
I'm going to very
quickly code it up,

512
00:24:17,500 --> 00:24:21,110
and then I'm going to
tell you what it does.

513
00:24:21,110 --> 00:24:26,350
So it's going to be a Sink
of products called addition.

514
00:24:26,350 --> 00:24:33,610
This is that input stream that
you can access externally.

515
00:24:33,610 --> 00:24:37,120
And then this is backed
by a stream controller

516
00:24:37,120 --> 00:24:40,090
called additionController.

517
00:24:40,090 --> 00:24:45,210
StreamController is just a basic
class in the stream library

518
00:24:45,210 --> 00:24:48,230
in Dart-- the core library.

519
00:24:48,230 --> 00:24:51,940
And that helps us listen
to the stream of things

520
00:24:51,940 --> 00:24:53,950
that are coming from outside.

521
00:24:53,950 --> 00:24:56,080
Now, how would you
use it in your app?

522
00:24:56,080 --> 00:24:59,920
You would just go to
the product squares,

523
00:24:59,920 --> 00:25:05,230
and wherever you are trying
to add the streams of events,

524
00:25:05,230 --> 00:25:08,770
you would just say cart bloc--

525
00:25:08,770 --> 00:25:09,940
the Sink.

526
00:25:09,940 --> 00:25:12,250
And then we want to
add to the Sink--

527
00:25:12,250 --> 00:25:16,300
in this case, we want
to add the products.

528
00:25:16,300 --> 00:25:20,380
Coming back, we want to
also code the output, which

529
00:25:20,380 --> 00:25:23,570
is a stream of itemCount.

530
00:25:23,570 --> 00:25:28,660
Let me just quickly do that--
itemCount is a stream of int.

531
00:25:28,660 --> 00:25:32,200
And it is backed by
something that you

532
00:25:32,200 --> 00:25:34,740
might know, BehaviorSubject.

533
00:25:34,740 --> 00:25:38,680
BehaviorSubject is
coming from ReactiveX,

534
00:25:38,680 --> 00:25:43,810
and it is a different
kind of stream controller

535
00:25:43,810 --> 00:25:46,040
that has memory of
its latest value.

536
00:25:46,040 --> 00:25:48,490
So, whenever you listen
to it, it will immediately

537
00:25:48,490 --> 00:25:50,200
give you that latest value.

538
00:25:50,200 --> 00:25:52,690
This is in contrast to
normal stream controllers,

539
00:25:52,690 --> 00:25:55,220
or streams, where,
when you listen to it,

540
00:25:55,220 --> 00:25:58,930
you will have to wait
until the value changes.

541
00:25:58,930 --> 00:26:02,210
That could be sometime
in the future.

542
00:26:02,210 --> 00:26:05,620
In our case, we want to
always have the latest value--

543
00:26:05,620 --> 00:26:09,400
the moment that we
listen to a stream.

544
00:26:09,400 --> 00:26:11,410
Now, how would we use that?

545
00:26:11,410 --> 00:26:15,166
Well, now we get to use
the StreamBuilder class.

546
00:26:15,166 --> 00:26:16,540
So we have the
cart button here--

547
00:26:16,540 --> 00:26:21,400
we want it to listen to
changes to the itemCount.

548
00:26:21,400 --> 00:26:26,440
I'm going to wrap it with a
StreamBuilder of integers.

549
00:26:26,440 --> 00:26:30,880
It's going to listen to
the itemCount stream.

550
00:26:30,880 --> 00:26:33,550
The initial data is
going to be zero.

551
00:26:33,550 --> 00:26:38,260
And then, in here, I can
just access the snapshot

552
00:26:38,260 --> 00:26:41,260
of the data, which will
always be the latest

553
00:26:41,260 --> 00:26:44,350
value of the itemCount.

554
00:26:44,350 --> 00:26:46,930
So we have this.

555
00:26:46,930 --> 00:26:52,010
Now, all we need to do is to
merge the streams together,

556
00:26:52,010 --> 00:26:53,794
so that's what I'm
going to do just now.

557
00:26:53,794 --> 00:26:55,210
MATT SULLIVAN:
This is where Filip

558
00:26:55,210 --> 00:26:57,084
will make the magic
happen behind the scenes,

559
00:26:57,084 --> 00:27:00,250
because we've got a bunch
of products coming inbound.

560
00:27:00,250 --> 00:27:01,840
And what we need
to do is we need

561
00:27:01,840 --> 00:27:04,507
to listen for changes on that,
because we're not capturing it

562
00:27:04,507 --> 00:27:05,090
at the moment.

563
00:27:05,090 --> 00:27:10,790
We need to add those
products to the cart itself.

564
00:27:10,790 --> 00:27:12,310
So what Filip is
doing now-- he's

565
00:27:12,310 --> 00:27:15,100
getting access to the
stream, he's listening to it.

566
00:27:15,100 --> 00:27:17,260
And then, the product will
be the event coming in,

567
00:27:17,260 --> 00:27:18,760
and all we need to
do at this point,

568
00:27:18,760 --> 00:27:20,420
then, is add that
product to the cart.

569
00:27:20,420 --> 00:27:20,920
Great.

570
00:27:20,920 --> 00:27:23,520
So now we have state managed.

571
00:27:23,520 --> 00:27:25,270
The other thing we
need to do is make sure

572
00:27:25,270 --> 00:27:29,020
that itemCount is always
updated when products are added.

573
00:27:29,020 --> 00:27:31,300
And all we need to do
there is do what we did,

574
00:27:31,300 --> 00:27:33,220
but in the opposite direction--

575
00:27:33,220 --> 00:27:36,700
is to add the itemCount
to the itemCount stream.

576
00:27:36,700 --> 00:27:39,630
And we're done?

577
00:27:39,630 --> 00:27:41,089
FILIP HRACEK: Yep, we're done.

578
00:27:41,089 --> 00:27:42,380
Back to you the slides, please.

579
00:27:42,380 --> 00:27:46,110


580
00:27:46,110 --> 00:27:51,140
So, as you could see, we were
able to implement this business

581
00:27:51,140 --> 00:27:53,160
logic component pretty quickly.

582
00:27:53,160 --> 00:27:55,310
It is a little more
complicated, but it gives you

583
00:27:55,310 --> 00:27:56,720
a lot of cool stuff.

584
00:27:56,720 --> 00:27:59,390


585
00:27:59,390 --> 00:28:03,620
First of all, it is really
just steams in, streams out.

586
00:28:03,620 --> 00:28:05,990
Whatever happens
in the component,

587
00:28:05,990 --> 00:28:08,900
you don't care about--

588
00:28:08,900 --> 00:28:11,120
as a Flutter UI.

589
00:28:11,120 --> 00:28:14,600
Then, we could add more
things to this bloc.

590
00:28:14,600 --> 00:28:18,770
So we could add a
stream of total cost.

591
00:28:18,770 --> 00:28:23,210
Whenever the cost
of the cart changes,

592
00:28:23,210 --> 00:28:27,410
you probably want to update
your user to give it that.

593
00:28:27,410 --> 00:28:31,910
And then, you have a stream
of lists of cart items, which

594
00:28:31,910 --> 00:28:33,920
is the items that you
want to always update

595
00:28:33,920 --> 00:28:37,700
whenever you add something to
the cart, or remove from it.

596
00:28:37,700 --> 00:28:38,920
So that is cool.

597
00:28:38,920 --> 00:28:41,630
And, again, these are
different aspects of our model

598
00:28:41,630 --> 00:28:44,670
that we want to show.

599
00:28:44,670 --> 00:28:47,780
Now, I have a problem
with one part of this,

600
00:28:47,780 --> 00:28:48,870
and that is this part.

601
00:28:48,870 --> 00:28:54,260
We're streaming the total cost
as integers, which makes sense

602
00:28:54,260 --> 00:28:56,360
internally in the component--

603
00:28:56,360 --> 00:28:59,990
it is a numerical
value, after all.

604
00:28:59,990 --> 00:29:05,630
But what it leads to is code
in your views like this.

605
00:29:05,630 --> 00:29:09,890
You have to somehow convert,
or format, the numerical value

606
00:29:09,890 --> 00:29:11,930
to some kind of string.

607
00:29:11,930 --> 00:29:15,080
Which is, if you think
about it, business logic--

608
00:29:15,080 --> 00:29:17,810
this shouldn't be in views.

609
00:29:17,810 --> 00:29:20,330
So you can go back
to your CartBloc,

610
00:29:20,330 --> 00:29:23,690
and you can just change
this to a stream of string

611
00:29:23,690 --> 00:29:25,340
that is already formatted.

612
00:29:25,340 --> 00:29:28,820
So whenever you want to
show your total cost,

613
00:29:28,820 --> 00:29:31,160
you just stream
the formatted one.

614
00:29:31,160 --> 00:29:34,640
And so you just reuse that
same business logic that

615
00:29:34,640 --> 00:29:37,100
is inside the component now.

616
00:29:37,100 --> 00:29:39,470
That gives you another
very cool thing,

617
00:29:39,470 --> 00:29:42,950
and that is that if
you add a new thing,

618
00:29:42,950 --> 00:29:45,410
or new input to the model--

619
00:29:45,410 --> 00:29:47,600
sorry, to the component--

620
00:29:47,600 --> 00:29:49,970
for example, Sink of Locale.

621
00:29:49,970 --> 00:29:53,480
So users, now, can change
anywhere in your app

622
00:29:53,480 --> 00:29:57,230
from a US shop to an EU shop.

623
00:29:57,230 --> 00:30:03,840
Now, you can pipe this change
as a stream to the total cost.

624
00:30:03,840 --> 00:30:06,530
And so, internally,
in the bloc, you

625
00:30:06,530 --> 00:30:10,250
will update the
total costs string,

626
00:30:10,250 --> 00:30:14,420
even though maybe the numerical
value is still the same.

627
00:30:14,420 --> 00:30:16,800
And that means that
anywhere in the app

628
00:30:16,800 --> 00:30:18,570
that the user changes
this, you don't

629
00:30:18,570 --> 00:30:21,110
need to think about
it as a developer.

630
00:30:21,110 --> 00:30:23,780
It will always update
anywhere else--

631
00:30:23,780 --> 00:30:25,010
the total cost.

632
00:30:25,010 --> 00:30:30,340
This would be a real pain
to implement any other way.

633
00:30:30,340 --> 00:30:35,160
So we have this nice
flow of data and events.

634
00:30:35,160 --> 00:30:37,920
We have widgets that
are only listening

635
00:30:37,920 --> 00:30:40,020
to what they need to know.

636
00:30:40,020 --> 00:30:42,780
And we're using good
old StreamBuilders

637
00:30:42,780 --> 00:30:43,740
to make that work.

638
00:30:43,740 --> 00:30:46,480


639
00:30:46,480 --> 00:30:49,020
MATT SULLIVAN: So let's take
a look at what we have now.

640
00:30:49,020 --> 00:30:51,810
Accessing state
in Fillips example

641
00:30:51,810 --> 00:30:54,180
was solved by using
the InheritedWidget

642
00:30:54,180 --> 00:30:58,090
pattern to pass access to
the bloc down the tree.

643
00:30:58,090 --> 00:31:00,990
We now have very fine
updating on change,

644
00:31:00,990 --> 00:31:02,550
because we have
different aspects

645
00:31:02,550 --> 00:31:05,100
of our data being represented
by different streams.

646
00:31:05,100 --> 00:31:08,940
And those widgets
subscribing to those screams

647
00:31:08,940 --> 00:31:12,060
will only rebuild when those
aspects of data changes.

648
00:31:12,060 --> 00:31:14,010
And, finally, we now
have the converse--

649
00:31:14,010 --> 00:31:17,210
we have mutating state
by pumping data--

650
00:31:17,210 --> 00:31:19,710
or requests to mutate state--

651
00:31:19,710 --> 00:31:21,720
into our business
logic, where we're

652
00:31:21,720 --> 00:31:24,960
observing for change, and
then we can update it there.

653
00:31:24,960 --> 00:31:27,600
There's this nice pattern of
pushing data in via streams,

654
00:31:27,600 --> 00:31:32,010
and then updating via streams,
which we think is very elegant.

655
00:31:32,010 --> 00:31:34,800
This is great, but
you all have options.

656
00:31:34,800 --> 00:31:38,040
SetState() works fine if you
have a very shallow tree,

657
00:31:38,040 --> 00:31:39,870
and your app is fairly simple.

658
00:31:39,870 --> 00:31:42,960
ScopedModel is a fantastic
way for a model, which

659
00:31:42,960 --> 00:31:46,230
is relatively straightforward,
to be passed up and down,

660
00:31:46,230 --> 00:31:49,890
and change on a tree
of arbitrary depth.

661
00:31:49,890 --> 00:31:52,230
For those of you who
like the redux pattern,

662
00:31:52,230 --> 00:31:54,600
there is an excellent
redux implementation built

663
00:31:54,600 --> 00:31:57,000
by the community-- the
redux package for Dart,

664
00:31:57,000 --> 00:32:01,320
and Flutter Redux
for Flutter, which

665
00:32:01,320 --> 00:32:03,810
will give you that pattern,
and you can use that as well.

666
00:32:03,810 --> 00:32:05,820
But if there's one
thing that we'd

667
00:32:05,820 --> 00:32:08,130
like you to take
away from this, it's

668
00:32:08,130 --> 00:32:13,720
that Flutter's widgets, in
combination with streams,

669
00:32:13,720 --> 00:32:17,830
gives you a very reactive way
to not only handle your UI,

670
00:32:17,830 --> 00:32:20,230
but handle the flow of
data through your app,

671
00:32:20,230 --> 00:32:24,400
and handle the updating of
your UI when that data changes.

672
00:32:24,400 --> 00:32:26,830
So we highly recommend
you go and check

673
00:32:26,830 --> 00:32:34,150
out Dart Streams, and the rxdart
as an option for building state

674
00:32:34,150 --> 00:32:35,500
in your apps.

675
00:32:35,500 --> 00:32:36,980
We'd love to hear from you.

676
00:32:36,980 --> 00:32:40,396
Please go to the site,
and give us some feedback.

677
00:32:40,396 --> 00:32:41,770
All of the code
you've seen today

678
00:32:41,770 --> 00:32:43,841
is in Fillips GitHub account.

679
00:32:43,841 --> 00:32:45,340
I did some pull
requests-- honestly,

680
00:32:45,340 --> 00:32:46,810
he didn't write everything.

681
00:32:46,810 --> 00:32:48,880
And not only do we show
you the code we showed,

682
00:32:48,880 --> 00:32:50,364
but we have a redux
implementation

683
00:32:50,364 --> 00:32:52,780
and a couple of others there
as well for you to check out.

684
00:32:52,780 --> 00:32:54,529
I want to give a shout
out to the cookbook

685
00:32:54,529 --> 00:32:57,040
that us and the community
have been working on.

686
00:32:57,040 --> 00:32:59,110
There's some wonderful
patterns in there--

687
00:32:59,110 --> 00:33:02,440
everything from widget
creation, to network, to JSON.

688
00:33:02,440 --> 00:33:03,820
It's a great place to go.

689
00:33:03,820 --> 00:33:05,410
And there were two
other talks that

690
00:33:05,410 --> 00:33:06,577
have happened prior to this.

691
00:33:06,577 --> 00:33:08,701
Fortunately, we have a time
machine called YouTube,

692
00:33:08,701 --> 00:33:09,880
so you can go back in time.

693
00:33:09,880 --> 00:33:12,370
And if you want to learn
about building beautiful UIs,

694
00:33:12,370 --> 00:33:15,130
or building apps end-to-end, I
would recommend you check those

695
00:33:15,130 --> 00:33:16,660
out-- those are good talks.

696
00:33:16,660 --> 00:33:19,200
And I would like to say
thank you for your time.

697
00:33:19,200 --> 00:33:20,200
FILIP HRACEK: Thank you.

698
00:33:20,200 --> 00:33:23,679
[APPLAUSE]

699
00:33:23,679 --> 00:33:28,408
[MUSIC PLAYING]

700
00:33:28,408 --> 00:00:00,000


